---
phase: 01-quick-fix-ux
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - GhostEdit/Sources/AppDelegate.swift
autonomous: false
requirements:
  - QFX-01
  - QFX-02

must_haves:
  truths:
    - "After pressing cmd+E on text with errors, a before/after diff popup appears showing exact character-level changes"
    - "The diff popup auto-dismisses after 3 seconds without user interaction"
    - "After pressing cmd+E, selecting 'Undo Last Correction' from the menu bar restores the original pre-fix text"
    - "Undo works for both rule-based fixes (macOS 13-25) and Foundation Model fixes (macOS 26+)"
    - "The diff popup does NOT appear when no fixes were made (fixCount == 0)"
  artifacts:
    - path: "GhostEdit/Sources/AppDelegate.swift"
      provides: "QuickFixDiffPopupController class, recordLocalFixHistoryEntry method, wiring in handleLocalFixHotkey and applyRuleBasedFixes"
      contains: "QuickFixDiffPopupController"
  key_links:
    - from: "handleLocalFixHotkey()"
      to: "recordLocalFixHistoryEntry()"
      via: "called after successful fix in both Foundation Model and rule-based paths"
      pattern: "recordLocalFixHistoryEntry"
    - from: "handleLocalFixHotkey()"
      to: "showQuickFixDiffPopup()"
      via: "called after successful fix to display character-level diff"
      pattern: "showQuickFixDiffPopup"
    - from: "undoLastCorrectionAction()"
      to: "historyStore.lastSuccessfulEntry()"
      via: "existing wiring — now returns local fix entries too"
      pattern: "lastSuccessfulEntry"
---

<objective>
Add diff preview and undo support for local quick fix (cmd+E) corrections.

Purpose: Users currently get no visual feedback showing what changed after cmd+E, and the "Undo Last Correction" menu item silently fails for local fixes because no history entry is recorded. This plan adds both capabilities.

Output: Modified AppDelegate.swift with (1) a new `QuickFixDiffPopupController` class for the before/after diff popup, (2) a `recordLocalFixHistoryEntry()` method, and (3) wiring in both the Foundation Model and rule-based fix paths.
</objective>

<execution_context>
@/Users/nareshsekar/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nareshsekar/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-quick-fix-ux/01-RESEARCH.md

Primary source file:
@GhostEdit/Sources/AppDelegate.swift

Supporting (read-only references):
@GhostEdit/Sources/DiffSupport.swift
@GhostEdit/Sources/CorrectionHistoryStore.swift

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From GhostEdit/Sources/DiffSupport.swift:
```swift
enum DiffSegmentKind: Equatable {
    case equal
    case insertion
    case deletion
}

struct DiffSegment: Equatable {
    let kind: DiffSegmentKind
    let text: String
}

enum DiffSupport {
    static func charDiff(old: String, new: String) -> [DiffSegment]
    static func changeSummary(segments: [DiffSegment]) -> (insertions: Int, deletions: Int, unchanged: Int)
}
```

From GhostEdit/Sources/CorrectionHistoryStore.swift:
```swift
struct CorrectionHistoryEntry: Codable, Equatable {
    var id: UUID
    var timestamp: Date
    var originalText: String
    var generatedText: String
    var provider: String
    var model: String
    var durationMilliseconds: Int
    var succeeded: Bool
}

final class CorrectionHistoryStore {
    func append(_ entry: CorrectionHistoryEntry, limit: Int) throws
    func lastSuccessfulEntry() -> CorrectionHistoryEntry?
}
```

From GhostEdit/Sources/AppDelegate.swift (key existing methods):
```swift
// Line 19: property
private var liveFeedbackController: LiveFeedbackController?

// Line 437: existing undo — already works via historyStore.lastSuccessfulEntry()
@objc private func undoLastCorrectionAction()

// Line 636: local fix entry point — where wiring goes
private func handleLocalFixHotkey()

// Line 733: rule-based fix — currently returns Void, needs to return String? (fixed text)
private func applyRuleBasedFixes(text: String, pid: pid_t, element: AXUIElement, cursorLocation: Int)

// Line 1347: LLM processing start — dismiss diff popup here
private func startProcessingIndicator()

// Line 2087: refresh history UI
private func refreshHistoryWindowIfVisible()

// Line 2123: existing LLM history recording (pattern reference, not modified)
private func recordHistoryEntry(originalText:generatedText:provider:model:startedAt:succeeded:)

// Line 4610: HUDOverlayController — pattern reference for panel construction
final class HUDOverlayController { ... }

// Line 4973: LiveFeedbackController — widgetWindow is private at line 4983
final class LiveFeedbackController {
    private var widgetWindow: NSPanel?  // line 4983
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Record local fix history entries and wire undo support</name>
  <files>GhostEdit/Sources/AppDelegate.swift</files>
  <action>
Add local fix history recording so that `undoLastCorrectionAction()` (already fully implemented at line 437) can find and undo local fixes.

**Step 1 — Add `recordLocalFixHistoryEntry` method** (near line 2149, after `recordHistoryEntry` closes):

```swift
private func recordLocalFixHistoryEntry(original: String, fixed: String) {
    let entry = CorrectionHistoryEntry(
        id: UUID(),
        timestamp: Date(),
        originalText: original,
        generatedText: fixed,
        provider: "Local",
        model: "Harper",
        durationMilliseconds: 0,
        succeeded: true
    )
    let limit = configManager.loadConfig().historyLimit
    try? historyStore.append(entry, limit: limit)
    refreshHistoryWindowIfVisible()
}
```

Use `provider: "Local"` and `model: "Harper"` as sentinel strings. Do NOT modify `CorrectionHistoryEntry` schema — it is Codable and on-disk history.json must remain compatible.

**Step 2 — Change `applyRuleBasedFixes` return type** from `Void` to `String?`:

At line 733, change the method signature to:
```swift
@discardableResult
private func applyRuleBasedFixes(text: String, pid: pid_t, element: AXUIElement, cursorLocation: Int) -> String?
```

When `fixCount > 0`, return `nsText as String` after all fixes are applied. When `fixCount == 0`, return `nil`. This lets the caller (`handleLocalFixHotkey`) receive the fixed text without re-querying AX.

Specifically: after the `showHUD(state: .successWithCount(fixCount))` line (line 774), add `return nsText as String`. After the `showHUD(state: .success)` line (line 776), add `return nil`.

**Step 3 — Wire history recording in `handleLocalFixHotkey`** (line 636):

**Foundation Model path** (lines 685-707): After `AXUIElementSetAttributeValue` succeeds and before `self.showHUD(state: .success)` (line 700), add:
```swift
self.recordLocalFixHistoryEntry(original: currentText, fixed: trimmed)
```

**Rule-based path** (lines 708-710): Change both call sites (line 703 in the Foundation Model fallback and line 709 in the else branch) to capture the return value:
```swift
if let fixedText = self.applyRuleBasedFixes(text: currentText, pid: pid, element: element, cursorLocation: cursorLocation) {
    self.recordLocalFixHistoryEntry(original: currentText, fixed: fixedText)
}
```

This covers all three paths: Foundation Model success, Foundation Model fallback to rules, and direct rule-based (macOS <26).

**Do NOT modify `undoLastCorrectionAction()`** — it already works correctly via `historyStore.lastSuccessfulEntry()`. Once local fix entries are recorded, undo will find them automatically.
  </action>
  <verify>
    <automated>xcodebuild build -project GhostEdit.xcodeproj -scheme GhostEdit -configuration Release 2>&1 | tail -5</automated>
  </verify>
  <done>
    - `recordLocalFixHistoryEntry(original:fixed:)` method exists in AppDelegate
    - `applyRuleBasedFixes` returns `String?` (the fixed text or nil)
    - Both Foundation Model and rule-based paths call `recordLocalFixHistoryEntry` after successful fixes
    - `undoLastCorrectionAction()` is NOT modified — it works via existing `lastSuccessfulEntry()` which now returns local fix entries
    - Build succeeds with no errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Build QuickFixDiffPopupController and wire diff preview</name>
  <files>GhostEdit/Sources/AppDelegate.swift</files>
  <action>
Build a floating diff popup that shows before/after changes for 3 seconds after cmd+E.

**Step 1 — Add `quickFixDiffPopup` property** to AppDelegate (near line 18-19, with other instance vars):
```swift
private var quickFixDiffPopup: QuickFixDiffPopupController?
```

**Step 2 — Add `widgetFrame` accessor** to `LiveFeedbackController` (after `private var widgetWindow: NSPanel?` at line 4983):
```swift
var widgetFrame: NSRect? { widgetWindow?.frame }
```

This is a one-line computed property exposing the widget's frame for popup positioning.

**Step 3 — Create `QuickFixDiffPopupController` class** at the end of AppDelegate.swift (after `HUDOverlayController`, before the file ends — after line ~6195):

The class must:
- Be a `final class` (same pattern as `HUDOverlayController`)
- Own a `private var panel: NSPanel?` and `private var dismissWorkItem: DispatchWorkItem?`
- Have `static let autoDismissDelay: TimeInterval = 3.0`
- Have `static let popupWidth: CGFloat = 300` and `static let popupMaxHeight: CGFloat = 120`

**`show(segments:near:widgetFrame:)` method:**
1. Cancel any existing dismiss work item, order out existing panel
2. Call `buildPanel(segments:)` to construct the popup
3. Call `positionPanel(_:near:widgetFrame:)` to place it
4. Set `panel.alphaValue = 0`, call `orderFrontRegardless()`
5. Fade in using `NSAnimationContext.runAnimationGroup` (duration 0.15, ease-out)
6. Schedule auto-dismiss via `DispatchWorkItem` + `asyncAfter(deadline: .now() + 3.0)`

**`dismiss()` method:**
1. Cancel dismiss work item
2. Fade out panel (duration 0.2) using `NSAnimationContext.runAnimationGroup`
3. In completion handler: `panel.orderOut(nil)`, `self.panel = nil`

**`buildPanel(segments:)` → `NSPanel`:**
1. Create borderless `NSPanel` (styleMask: `.borderless | .nonactivatingPanel`, backing: `.buffered`, defer: true)
2. Set `panel.isFloatingPanel = true`, `panel.level = .floating`, `panel.hasShadow = true`
3. Set `panel.backgroundColor = .clear`
4. Add `NSVisualEffectView` with `.hudWindow` material, `.active` state, corner radius 8
5. Create `NSTextField` (non-editable, non-selectable, wrapping, no border, clear background)
6. Build `NSAttributedString` from segments using the DiffPreviewController pattern:
   - `.equal`: `font: .systemFont(ofSize: 12)`, `foregroundColor: .labelColor`
   - `.insertion`: `foregroundColor: .systemGreen`, `backgroundColor: .systemGreen.withAlphaComponent(0.15)`, `underlineStyle: .single`
   - `.deletion`: `foregroundColor: .systemRed`, `backgroundColor: .systemRed.withAlphaComponent(0.15)`, `strikethroughStyle: .single`
7. Set the attributed string on the text field
8. Size the panel: width = `popupWidth`, height = min(text field's intrinsic height + 16 padding, `popupMaxHeight`)
9. Add a click gesture recognizer on the panel's content view that calls `dismiss()` (dismiss on click)

**`positionPanel(_:near:widgetFrame:)` method:**
1. If `widgetFrame` is non-nil (live feedback widget visible): position popup directly above the widget frame (x = widgetFrame.origin.x, y = widgetFrame.origin.y + widgetFrame.height + 4)
2. Otherwise: query AX element position/size (same as `positionWidget(near:)` in `LiveFeedbackController`), convert from top-left screen coords to Cocoa bottom-left coords, position below the text field
3. Clamp: if popup Y < `screen.visibleFrame.minY`, flip to above the field. Clamp X to `[screen.visibleFrame.minX, screen.visibleFrame.maxX - popupWidth]`

**Step 4 — Add `showQuickFixDiffPopup` method** in AppDelegate (near `recordLocalFixHistoryEntry`):
```swift
private func showQuickFixDiffPopup(original: String, fixed: String, near element: AXUIElement) {
    let segments = DiffSupport.charDiff(old: original, new: fixed)
    guard segments.contains(where: { $0.kind != .equal }) else { return }

    quickFixDiffPopup?.dismiss()

    let popup = QuickFixDiffPopupController()
    popup.show(segments: segments, near: element, widgetFrame: liveFeedbackController?.widgetFrame)
    quickFixDiffPopup = popup
}
```

**Step 5 — Wire popup calls in `handleLocalFixHotkey`:**

**Foundation Model path** (after `recordLocalFixHistoryEntry` added in Task 1, before `self.showHUD`):
```swift
self.showQuickFixDiffPopup(original: currentText, fixed: trimmed, near: element)
```

**Rule-based path** (inside the `if let fixedText = ...` block added in Task 1):
```swift
self.showQuickFixDiffPopup(original: currentText, fixed: fixedText, near: element)
```

**Step 6 — Dismiss popup when LLM flow starts** (in `startProcessingIndicator()` at line 1347):
Add at the top of the method:
```swift
quickFixDiffPopup?.dismiss()
quickFixDiffPopup = nil
```

This prevents stacked popups if user presses cmd+shift+E right after cmd+E.

**Important anti-patterns to avoid:**
- Do NOT reuse `HUDOverlayController` — it is for the ghost icon overlay, not text diff display
- Do NOT modify `CorrectionHistoryEntry` struct — use existing fields with sentinel values
- Do NOT show popup when `fixCount == 0` — the `guard segments.contains(where:)` handles this
- Do NOT block the main thread for diff computation — `charDiff` is fast for typical text field content
  </action>
  <verify>
    <automated>xcodebuild build -project GhostEdit.xcodeproj -scheme GhostEdit -configuration Release 2>&1 | tail -5</automated>
  </verify>
  <done>
    - `QuickFixDiffPopupController` class exists at end of AppDelegate.swift with show/dismiss/buildPanel/positionPanel methods
    - `LiveFeedbackController` exposes `var widgetFrame: NSRect?`
    - `showQuickFixDiffPopup(original:fixed:near:)` method exists in AppDelegate
    - Both Foundation Model and rule-based paths call `showQuickFixDiffPopup` after successful fixes
    - `startProcessingIndicator()` dismisses any active diff popup
    - Popup uses `DiffSupport.charDiff()` for character-level diff with green insertions / red deletions
    - Popup auto-dismisses after 3 seconds and dismisses on click
    - Build succeeds with no errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify diff preview and undo in running app</name>
  <files>GhostEdit/Sources/AppDelegate.swift</files>
  <action>
    Human verifies the complete diff preview and undo support for local quick fix (cmd+E). After pressing cmd+E on text with errors:
    1. A floating before/after diff popup appears near the widget (or text field) showing green insertions and red strikethrough deletions
    2. The popup auto-dismisses after 3 seconds (or click to dismiss early)
    3. "Undo Last Correction" in the menu bar restores the original text

    Build and install the app:
    ```
    osascript -e 'tell application "GhostEdit" to quit' 2>/dev/null; sleep 1
    xcodebuild build -project GhostEdit.xcodeproj -scheme GhostEdit -configuration Release
    rm -rf /Applications/GhostEdit.app
    cp -R "$(xcodebuild build -project GhostEdit.xcodeproj -scheme GhostEdit -configuration Release -showBuildSettings 2>/dev/null | grep -m1 BUILT_PRODUCTS_DIR | awk '{print $NF}')/GhostEdit.app" /Applications/GhostEdit.app
    codesign --force --deep --sign - /Applications/GhostEdit.app
    open /Applications/GhostEdit.app
    ```

    Test diff popup (QFX-01):
    a. Open TextEdit, type "Ths is a tset" (intentional errors)
    b. Press cmd+E
    c. Verify: A floating popup appears near the widget/text field showing the diff with green text (corrections) and red strikethrough (original errors)
    d. Verify: The popup auto-dismisses after ~3 seconds
    e. Click the popup before 3 seconds — verify it dismisses immediately

    Test undo (QFX-02):
    a. After cmd+E corrects text, click the GhostEdit menu bar icon
    b. Click "Undo Last Correction"
    c. Verify: The original misspelled text is restored in TextEdit

    Test no-change case:
    a. Type "This is correct." (no errors)
    b. Press cmd+E
    c. Verify: No diff popup appears (HUD shows success but no popup)

    Test that LLM flow dismisses popup:
    a. Type text with errors, press cmd+E (popup appears)
    b. Immediately press cmd+shift+E
    c. Verify: The diff popup is dismissed when LLM processing starts
  </action>
  <verify>
    <automated>xcodebuild build -project GhostEdit.xcodeproj -scheme GhostEdit -configuration Release 2>&1 | tail -5</automated>
  </verify>
  <done>All 4 manual test scenarios pass: diff popup appears with correct styling, auto-dismisses after 3 seconds, undo restores original text, no popup when no changes made, and LLM flow dismisses popup</done>
</task>

</tasks>

<verification>
1. `xcodebuild build -project GhostEdit.xcodeproj -scheme GhostEdit -configuration Release` — succeeds with no errors
2. `xcodebuild test -project GhostEdit.xcodeproj -scheme GhostEditTests -destination 'platform=macOS'` — all 432+ tests pass (no guarded files modified)
3. Manual: cmd+E on misspelled text shows diff popup with green/red highlighting
4. Manual: diff popup disappears after 3 seconds
5. Manual: "Undo Last Correction" restores pre-fix text after cmd+E
6. Manual: No diff popup when text has no errors
</verification>

<success_criteria>
- After cmd+E on text with errors, a before/after diff popup appears showing exact character-level changes (green insertions, red strikethrough deletions)
- The popup auto-dismisses after 3 seconds without user interaction
- "Undo Last Correction" in the menu bar successfully restores the original text after a cmd+E local fix
- No diff popup appears when the text has no fixable issues
- Build succeeds and all existing tests pass (zero guarded file changes = zero coverage risk)
</success_criteria>

<output>
After completion, create `.planning/phases/01-quick-fix-ux/01-01-SUMMARY.md`
</output>
